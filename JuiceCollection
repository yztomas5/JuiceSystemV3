local Players = game:GetService("Players")
local ReplicatedStorage = game:GetService("ReplicatedStorage")
local RunService = game:GetService("RunService")
local DataStoreService = game:GetService("DataStoreService")

local JuiceCollection = {}

local Trove = require(ReplicatedStorage:WaitForChild("Modules"):WaitForChild("Data"):WaitForChild("Trove"))

local moneyVFX = ReplicatedStorage:WaitForChild("Assets"):WaitForChild("VFX"):WaitForChild("Money")
local JuiceDataStore = DataStoreService:GetDataStore("JuiceOfflineData")

local COLLECTION_COOLDOWN = 1

-- Bonus system constants
local BONUS_CHANCE = 0.02 -- 2% chance (adjustable)
local BONUS_MULTIPLIER = 1.5 -- 1.5x multiplier when bonus activates

local systemTrove = Trove.new()

function JuiceCollection.playMoneyEffect(collectPart)
	local moneyEffect = moneyVFX:Clone()
	moneyEffect.CFrame = collectPart.CFrame
	moneyEffect.Parent = collectPart

	local cashSound = moneyEffect:FindFirstChild("Cash")
	if cashSound and cashSound:IsA("Sound") then
		cashSound:Play()
	end

	for _, child in ipairs(moneyEffect:GetDescendants()) do
		if child:IsA("ParticleEmitter") then
			child.Enabled = true
		end
	end

	task.delay(0.2, function()
		if moneyEffect and moneyEffect.Parent then
			for _, child in ipairs(moneyEffect:GetDescendants()) do
				if child:IsA("ParticleEmitter") then
					child.Enabled = false
				end
			end
		end
	end)

	task.delay(1.5, function()
		if moneyEffect and moneyEffect.Parent then
			moneyEffect:Destroy()
		end
	end)
end

function JuiceCollection.connectSlotCollection(player, slotNumber, collectPart, slotTracker)
	local userId = player.UserId

	local connection = collectPart.Touched:Connect(function(hit)
		local character = hit.Parent
		if not character then return end

		local touchingPlayer = Players:GetPlayerFromCharacter(character)
		if not touchingPlayer or touchingPlayer ~= player then return end

		if slotTracker.isOnCooldown(userId, slotNumber, COLLECTION_COOLDOWN) then
			return
		end

		local placedJuices = player:FindFirstChild("PlacedJuices")
		if not placedJuices then return end

		local juiceFolder = nil
		for _, folder in ipairs(placedJuices:GetChildren()) do
			local slotValue = folder:FindFirstChild("Slot")
			if slotValue and slotValue:IsA("IntValue") and slotValue.Value == slotNumber then
				juiceFolder = folder
				break
			end
		end

		if not juiceFolder then return end

		local moneyGenerated = juiceFolder:FindFirstChild("MoneyGenerated")
		if not moneyGenerated or not moneyGenerated:IsA("IntValue") then return end

		if moneyGenerated.Value <= 0 then return end

		local multiplierValue = JuiceCollection.getPlayerMoneyMultiplier(player)

		local finalMoney = moneyGenerated.Value * multiplierValue

		if JuiceCollection.addMoneyToPlayer(player, finalMoney) then

			JuiceCollection.playMoneyEffect(collectPart)

			moneyGenerated.Value = 0

			slotTracker.setCooldown(userId, slotNumber, tick())
		end
	end)

	return connection
end

function JuiceCollection.connectCollectZoneCollection(player, collectPart, slotTracker)
	local userId = player.UserId

	local connection = collectPart.Touched:Connect(function(hit)
		local character = hit.Parent
		if not character then return end

		local touchingPlayer = Players:GetPlayerFromCharacter(character)
		if not touchingPlayer or touchingPlayer ~= player then return end

		if slotTracker.isOnCooldown(userId, "collectzone", COLLECTION_COOLDOWN) then
			return
		end

		local placedJuices = player:FindFirstChild("PlacedJuices")
		if not placedJuices then return end

		local totalMoneyGenerated = 0
		local juiceFolders = {}

		for _, juiceFolder in ipairs(placedJuices:GetChildren()) do
			if juiceFolder:IsA("Folder") then
				local moneyGenerated = juiceFolder:FindFirstChild("MoneyGenerated")
				if moneyGenerated and moneyGenerated:IsA("IntValue") and moneyGenerated.Value > 0 then
					totalMoneyGenerated = totalMoneyGenerated + moneyGenerated.Value
					table.insert(juiceFolders, juiceFolder)
				end
			end
		end

		if totalMoneyGenerated <= 0 then return end

		local multiplierValue = JuiceCollection.getPlayerMoneyMultiplier(player)

		local finalMoney = totalMoneyGenerated * multiplierValue

		if JuiceCollection.addMoneyToPlayer(player, finalMoney) then

			JuiceCollection.playMoneyEffect(collectPart)

			for _, juiceFolder in ipairs(juiceFolders) do
				local moneyGenerated = juiceFolder:FindFirstChild("MoneyGenerated")
				if moneyGenerated and moneyGenerated:IsA("IntValue") then
					moneyGenerated.Value = 0
				end
			end

			slotTracker.setCooldown(userId, "collectzone", tick())
		end
	end)

	return connection
end

function JuiceCollection.getPlayerMoneyMultiplier(player)
	local dataFolder = player:FindFirstChild("Data")
	if not dataFolder then return 1 end

	local moneyMultiplier = dataFolder:FindFirstChild("MoneyMultiplier")
	if moneyMultiplier and moneyMultiplier:IsA("IntValue") then
		return moneyMultiplier.Value
	end

	return 1
end

function JuiceCollection.addMoneyToPlayer(player, amount)
	local dataFolder = player:FindFirstChild("Data")
	if not dataFolder then return false end

	local moneyValue = dataFolder:FindFirstChild("Money")
	if not moneyValue or not moneyValue:IsA("IntValue") then return false end

	moneyValue.Value = moneyValue.Value + amount
	return true
end

function JuiceCollection.updateCollectZoneGui(player, collectZone, formatNumberFunc)
	local basePart = collectZone:FindFirstChild("Base")
	if not basePart or not basePart:IsA("BasePart") then return end

	local slotGui = basePart:FindFirstChild("Slot")
	if not slotGui or not slotGui:IsA("BillboardGui") then return end

	local info = slotGui:FindFirstChild("Info")
	if not info then return end

	local pricePerSecLabel = info:FindFirstChild("PricePerSec")
	local multiplierLabel = info:FindFirstChild("Multiplier")

	local totalMoneyGenerated = JuiceCollection.getTotalMoneyGenerated(player)

	if pricePerSecLabel and pricePerSecLabel:IsA("TextLabel") then
		pricePerSecLabel.Text = formatNumberFunc(totalMoneyGenerated)
	end

	if multiplierLabel and multiplierLabel:IsA("TextLabel") then
		local moneyMultiplier = JuiceCollection.getPlayerMoneyMultiplier(player)
		multiplierLabel.Text = "MONEY MULTI: X" .. tostring(moneyMultiplier)
	end
end

function JuiceCollection.getTotalMoneyGenerated(player)
	local placedJuices = player:FindFirstChild("PlacedJuices")
	local totalMoneyGenerated = 0

	if placedJuices then
		for _, juiceFolder in ipairs(placedJuices:GetChildren()) do
			if juiceFolder:IsA("Folder") then
				local moneyGenerated = juiceFolder:FindFirstChild("MoneyGenerated")
				if moneyGenerated and moneyGenerated:IsA("IntValue") then
					totalMoneyGenerated = totalMoneyGenerated + moneyGenerated.Value
				end
			end
		end
	end

	return totalMoneyGenerated
end

function JuiceCollection.playBonusEffect(collectPart)
	-- Clone the bonus VFX
	local bonusVFXFolder = ReplicatedStorage:WaitForChild("Assets"):WaitForChild("VFX"):WaitForChild("Bonus")
	local burstTemplate = bonusVFXFolder:FindFirstChild("Burst")

	if not burstTemplate then
		warn("[JuiceCollection] Bonus Burst VFX not found in ReplicatedStorage.Assets.VFX.Bonus")
		return
	end

	local burstClone = burstTemplate:Clone()
	burstClone.CFrame = collectPart.CFrame
	burstClone.Parent = collectPart

	-- Find all particle emitters and the sound
	local particles = {}
	local sound = burstClone:FindFirstChild("Effect")

	for _, descendant in ipairs(burstClone:GetDescendants()) do
		if descendant:IsA("ParticleEmitter") then
			table.insert(particles, descendant)
			descendant.Enabled = false
		end
	end

	-- Play the effect once
	task.spawn(function()
		-- Activate particles
		for _, particle in ipairs(particles) do
			particle.Enabled = true
		end

		-- Play sound
		if sound and sound:IsA("Sound") then
			sound:Play()
		end

		-- Keep particles active for 0.5 seconds
		task.wait(0.5)

		-- Deactivate particles
		for _, particle in ipairs(particles) do
			particle.Enabled = false
		end

		-- Wait for sound to finish
		if sound and sound:IsA("Sound") then
			if sound.TimeLength > 0 then
				task.wait(sound.TimeLength)
			else
				sound.Ended:Wait()
			end
		end

		-- Destroy the effect after a small delay
		task.wait(0.5)
		if burstClone and burstClone.Parent then
			burstClone:Destroy()
		end
	end)
end

function JuiceCollection.updateAllJuicesMoneyGeneration()
	local JuiceSystemPath = ReplicatedStorage:WaitForChild("Modules"):WaitForChild("Utils"):WaitForChild("JuiceSystem")
	local JuiceSystemUtils = require(JuiceSystemPath:WaitForChild("JuiceSystemUtils"))

	for _, player in ipairs(Players:GetPlayers()) do
		local placedJuices = player:FindFirstChild("PlacedJuices")
		if placedJuices then
			-- Collect all valid juices for this player
			local validJuices = {}

			for _, juiceFolder in ipairs(placedJuices:GetChildren()) do
				if juiceFolder:IsA("Folder") then
					local pricePerSecValue = juiceFolder:FindFirstChild("PricePerSec")
					local moneyGeneratedValue = juiceFolder:FindFirstChild("MoneyGenerated")
					local slotValue = juiceFolder:FindFirstChild("Slot")

					if pricePerSecValue and pricePerSecValue:IsA("IntValue") and
						moneyGeneratedValue and moneyGeneratedValue:IsA("IntValue") and
						slotValue and slotValue:IsA("IntValue") then

						table.insert(validJuices, {
							pricePerSec = pricePerSecValue,
							moneyGenerated = moneyGeneratedValue,
							slot = slotValue,
							folder = juiceFolder
						})
					end
				end
			end

			-- Check for global bonus activation (2% chance per player)
			local bonusActivated = #validJuices > 0 and math.random() < BONUS_CHANCE

			if bonusActivated then
				-- Select a random juice to receive the bonus
				local randomIndex = math.random(1, #validJuices)
				local luckyJuice = validJuices[randomIndex]

				-- Apply bonus multiplier to the lucky juice
				local bonusMoney = math.floor(luckyJuice.pricePerSec.Value * BONUS_MULTIPLIER)
				luckyJuice.moneyGenerated.Value = luckyJuice.moneyGenerated.Value + bonusMoney

				-- Play bonus effect on the lucky juice's Collect part
				local slotModel = JuiceSystemUtils.findSlotModel(player, luckyJuice.slot.Value)
				if slotModel then
					local collectPart = slotModel:FindFirstChild("Collect")
					if collectPart and collectPart:IsA("BasePart") then
						JuiceCollection.playBonusEffect(collectPart)
					end
				end

				-- Apply normal generation to all other juices
				for i, juiceData in ipairs(validJuices) do
					if i ~= randomIndex then
						juiceData.moneyGenerated.Value = juiceData.moneyGenerated.Value + juiceData.pricePerSec.Value
					end
				end
			else
				-- No bonus: apply normal generation to all juices
				for _, juiceData in ipairs(validJuices) do
					juiceData.moneyGenerated.Value = juiceData.moneyGenerated.Value + juiceData.pricePerSec.Value
				end
			end
		end
	end
end

function JuiceCollection.startMoneyGenerationSystem()
	local lastUpdateTime = os.time()

	systemTrove:Connect(RunService.Heartbeat, function()
		local currentTime = os.time()

		if currentTime > lastUpdateTime then
			lastUpdateTime = currentTime
			JuiceCollection.updateAllJuicesMoneyGeneration()
		end
	end)
end

function JuiceCollection.calculateOfflineMoney(player)
	local success, lastDisconnectTime = pcall(function()
		return JuiceDataStore:GetAsync("Player_" .. player.UserId)
	end)

	if not success or not lastDisconnectTime then
		return
	end

	local currentTime = os.time()
	local timeOffline = currentTime - lastDisconnectTime

	if timeOffline <= 0 then return end

	local MAX_OFFLINE_TIME = 10800
	if timeOffline > MAX_OFFLINE_TIME then
		timeOffline = MAX_OFFLINE_TIME
	end

	local placedJuices = player:FindFirstChild("PlacedJuices")
	if not placedJuices then return end

	for _, juiceFolder in ipairs(placedJuices:GetChildren()) do
		if juiceFolder:IsA("Folder") then
			local pricePerSecValue = juiceFolder:FindFirstChild("PricePerSec")
			local moneyGeneratedValue = juiceFolder:FindFirstChild("MoneyGenerated")

			if pricePerSecValue and pricePerSecValue:IsA("IntValue") and
				moneyGeneratedValue and moneyGeneratedValue:IsA("IntValue") then

				local offlineMoney = pricePerSecValue.Value * timeOffline
				moneyGeneratedValue.Value = moneyGeneratedValue.Value + offlineMoney
			end
		end
	end
end

function JuiceCollection.saveDisconnectTime(player)
	local success, err = pcall(function()
		JuiceDataStore:SetAsync("Player_" .. player.UserId, os.time())
	end)
end

return JuiceCollection
