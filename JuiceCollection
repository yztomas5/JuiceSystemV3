local Players = game:GetService("Players")
local ReplicatedStorage = game:GetService("ReplicatedStorage")
local RunService = game:GetService("RunService")
local DataStoreService = game:GetService("DataStoreService")

local JuiceCollection = {}

local Trove = require(ReplicatedStorage:WaitForChild("Modules"):WaitForChild("Data"):WaitForChild("Trove"))

local moneyVFX = ReplicatedStorage:WaitForChild("Assets"):WaitForChild("VFX"):WaitForChild("Money")
local JuiceDataStore = DataStoreService:GetDataStore("JuiceOfflineData")

local COLLECTION_COOLDOWN = 1

-- Bonus system constants
local BONUS_CHANCE = 0.02 -- 2% chance (adjustable)
local BONUS_MULTIPLIER = 1.5 -- 1.5x multiplier when bonus activates

local systemTrove = Trove.new()

function JuiceCollection.playMoneyEffect(collectPart)
	local moneyEffect = moneyVFX:Clone()
	moneyEffect.CFrame = collectPart.CFrame
	moneyEffect.Parent = collectPart

	local cashSound = moneyEffect:FindFirstChild("Cash")
	if cashSound and cashSound:IsA("Sound") then
		cashSound:Play()
	end

	for _, child in ipairs(moneyEffect:GetDescendants()) do
		if child:IsA("ParticleEmitter") then
			child.Enabled = true
		end
	end

	task.delay(0.2, function()
		if moneyEffect and moneyEffect.Parent then
			for _, child in ipairs(moneyEffect:GetDescendants()) do
				if child:IsA("ParticleEmitter") then
					child.Enabled = false
				end
			end
		end
	end)

	task.delay(1.5, function()
		if moneyEffect and moneyEffect.Parent then
			moneyEffect:Destroy()
		end
	end)
end

function JuiceCollection.connectSlotCollection(player, slotNumber, collectPart, slotTracker)
	local userId = player.UserId

	local connection = collectPart.Touched:Connect(function(hit)
		local character = hit.Parent
		if not character then return end

		local touchingPlayer = Players:GetPlayerFromCharacter(character)
		if not touchingPlayer or touchingPlayer ~= player then return end

		if slotTracker.isOnCooldown(userId, slotNumber, COLLECTION_COOLDOWN) then
			return
		end

		local placedJuices = player:FindFirstChild("PlacedJuices")
		if not placedJuices then return end

		local juiceFolder = nil
		for _, folder in ipairs(placedJuices:GetChildren()) do
			local slotValue = folder:FindFirstChild("Slot")
			if slotValue and slotValue:IsA("IntValue") and slotValue.Value == slotNumber then
				juiceFolder = folder
				break
			end
		end

		if not juiceFolder then return end

		local moneyGenerated = juiceFolder:FindFirstChild("MoneyGenerated")
		if not moneyGenerated or not moneyGenerated:IsA("IntValue") then return end

		if moneyGenerated.Value <= 0 then return end

		local multiplierValue = JuiceCollection.getPlayerMoneyMultiplier(player)

		local finalMoney = moneyGenerated.Value * multiplierValue

		if JuiceCollection.addMoneyToPlayer(player, finalMoney) then

			JuiceCollection.playMoneyEffect(collectPart)

			moneyGenerated.Value = 0

			slotTracker.setCooldown(userId, slotNumber, tick())
		end
	end)

	return connection
end

function JuiceCollection.connectCollectZoneCollection(player, collectPart, slotTracker)
	local userId = player.UserId

	local connection = collectPart.Touched:Connect(function(hit)
		local character = hit.Parent
		if not character then return end

		local touchingPlayer = Players:GetPlayerFromCharacter(character)
		if not touchingPlayer or touchingPlayer ~= player then return end

		if slotTracker.isOnCooldown(userId, "collectzone", COLLECTION_COOLDOWN) then
			return
		end

		local placedJuices = player:FindFirstChild("PlacedJuices")
		if not placedJuices then return end

		local totalMoneyGenerated = 0
		local juiceFolders = {}

		for _, juiceFolder in ipairs(placedJuices:GetChildren()) do
			if juiceFolder:IsA("Folder") then
				local moneyGenerated = juiceFolder:FindFirstChild("MoneyGenerated")
				if moneyGenerated and moneyGenerated:IsA("IntValue") and moneyGenerated.Value > 0 then
					totalMoneyGenerated = totalMoneyGenerated + moneyGenerated.Value
					table.insert(juiceFolders, juiceFolder)
				end
			end
		end

		if totalMoneyGenerated <= 0 then return end

		local multiplierValue = JuiceCollection.getPlayerMoneyMultiplier(player)

		local finalMoney = totalMoneyGenerated * multiplierValue

		if JuiceCollection.addMoneyToPlayer(player, finalMoney) then

			JuiceCollection.playMoneyEffect(collectPart)

			for _, juiceFolder in ipairs(juiceFolders) do
				local moneyGenerated = juiceFolder:FindFirstChild("MoneyGenerated")
				if moneyGenerated and moneyGenerated:IsA("IntValue") then
					moneyGenerated.Value = 0
				end
			end

			slotTracker.setCooldown(userId, "collectzone", tick())
		end
	end)

	return connection
end

function JuiceCollection.getPlayerMoneyMultiplier(player)
	local dataFolder = player:FindFirstChild("Data")
	if not dataFolder then return 1 end

	local moneyMultiplier = dataFolder:FindFirstChild("MoneyMultiplier")
	if moneyMultiplier and moneyMultiplier:IsA("IntValue") then
		return moneyMultiplier.Value
	end

	return 1
end

function JuiceCollection.addMoneyToPlayer(player, amount)
	local dataFolder = player:FindFirstChild("Data")
	if not dataFolder then return false end

	local moneyValue = dataFolder:FindFirstChild("Money")
	if not moneyValue or not moneyValue:IsA("IntValue") then return false end

	moneyValue.Value = moneyValue.Value + amount
	return true
end

function JuiceCollection.updateCollectZoneGui(player, collectZone, formatNumberFunc)
	local basePart = collectZone:FindFirstChild("Base")
	if not basePart or not basePart:IsA("BasePart") then return end

	local slotGui = basePart:FindFirstChild("Slot")
	if not slotGui or not slotGui:IsA("BillboardGui") then return end

	local info = slotGui:FindFirstChild("Info")
	if not info then return end

	local pricePerSecLabel = info:FindFirstChild("PricePerSec")
	local multiplierLabel = info:FindFirstChild("Multiplier")

	local totalMoneyGenerated = JuiceCollection.getTotalMoneyGenerated(player)

	if pricePerSecLabel and pricePerSecLabel:IsA("TextLabel") then
		pricePerSecLabel.Text = formatNumberFunc(totalMoneyGenerated)
	end

	if multiplierLabel and multiplierLabel:IsA("TextLabel") then
		local moneyMultiplier = JuiceCollection.getPlayerMoneyMultiplier(player)
		multiplierLabel.Text = "MONEY MULTI: X" .. tostring(moneyMultiplier)
	end
end

function JuiceCollection.getTotalMoneyGenerated(player)
	local placedJuices = player:FindFirstChild("PlacedJuices")
	local totalMoneyGenerated = 0

	if placedJuices then
		for _, juiceFolder in ipairs(placedJuices:GetChildren()) do
			if juiceFolder:IsA("Folder") then
				local moneyGenerated = juiceFolder:FindFirstChild("MoneyGenerated")
				if moneyGenerated and moneyGenerated:IsA("IntValue") then
					totalMoneyGenerated = totalMoneyGenerated + moneyGenerated.Value
				end
			end
		end
	end

	return totalMoneyGenerated
end

function JuiceCollection.playBonusEffect(collectPart, player)
	-- Clone the bonus VFX (Burst)
	local bonusVFXFolder = ReplicatedStorage:WaitForChild("Assets"):WaitForChild("VFX"):WaitForChild("Bonus")
	local burstTemplate = bonusVFXFolder:FindFirstChild("Burst")

	if not burstTemplate then
		warn("[JuiceCollection] Bonus Burst VFX not found in ReplicatedStorage.Assets.VFX.Bonus")
		return
	end

	local burstClone = burstTemplate:Clone()
	burstClone.CFrame = collectPart.CFrame
	burstClone.Parent = collectPart

	-- Find all particle emitters and the sound
	local particles = {}
	local sound = burstClone:FindFirstChild("Effect")

	for _, descendant in ipairs(burstClone:GetDescendants()) do
		if descendant:IsA("ParticleEmitter") then
			table.insert(particles, descendant)
			descendant.Enabled = false
		end
	end

	-- Play the Burst effect once
	task.spawn(function()
		-- Activate particles
		for _, particle in ipairs(particles) do
			particle.Enabled = true
		end

		-- Play sound
		if sound and sound:IsA("Sound") then
			sound:Play()
		end

		-- Keep particles active for 0.5 seconds
		task.wait(0.5)

		-- Deactivate particles
		for _, particle in ipairs(particles) do
			particle.Enabled = false
		end

		-- Wait for sound to finish
		if sound and sound:IsA("Sound") then
			if sound.TimeLength > 0 then
				task.wait(sound.TimeLength)
			else
				sound.Ended:Wait()
			end
		end

		-- Destroy the effect after a small delay
		task.wait(0.5)
		if burstClone and burstClone.Parent then
			burstClone:Destroy()
		end
	end)

	-- Now create the money Bezier effect
	task.spawn(function()
		JuiceCollection.createMoneyBezierEffect(collectPart, player)
	end)
end

function JuiceCollection.createMoneyBezierEffect(collectPart, player)
	local Debris = game:GetService("Debris")
	local TweenService = game:GetService("TweenService")

	-- Load Bezier module
	local Bezier = require(ReplicatedStorage:WaitForChild("Modules"):WaitForChild("Utils"):WaitForChild("Bezier"))

	-- Get templates and sounds
	local bonusFolder = ReplicatedStorage:WaitForChild("Assets"):WaitForChild("VFX"):WaitForChild("Bonus")
	local moneyTemplate = bonusFolder:FindFirstChild("Money")
	if not moneyTemplate then
		warn("[JuiceCollection] Money template not found")
		return
	end

	local soundsFolder = ReplicatedStorage:WaitForChild("Assets"):WaitForChild("Sounds"):WaitForChild("SFX"):WaitForChild("Bonus")
	local rewardSound = soundsFolder:FindFirstChild("Reward")
	local transitionSound = soundsFolder:FindFirstChild("Transition")
	local collectedSound = soundsFolder:FindFirstChild("Collected")

	-- Find the CollectZone for the player
	local JuiceSystemPath = ReplicatedStorage:WaitForChild("Modules"):WaitForChild("Utils"):WaitForChild("JuiceSystem")
	local JuiceSystemUtils = require(JuiceSystemPath:WaitForChild("JuiceSystemUtils"))
	local collectZone = JuiceSystemUtils.findCollectZone(player)

	if not collectZone then
		warn("[JuiceCollection] CollectZone not found for player")
		return
	end

	local collectZoneCollectPart = collectZone:FindFirstChild("Collect")
	if not collectZoneCollectPart or not collectZoneCollectPart:IsA("BasePart") then
		warn("[JuiceCollection] Collect part not found in CollectZone")
		return
	end

	-- Configuration
	local NUM_COINS = 5
	local DELAY_BETWEEN_COINS = 0.2
	local FIRST_BEZIER_DURATION = 0.5
	local BOUNCE_HEIGHT = 2
	local BOUNCE_DURATION = 0.3
	local SECOND_BEZIER_DURATION = 0.6

	local centro = collectPart.Position

	-- Spawn each coin sequentially
	for i = 1, NUM_COINS do
		task.spawn(function()
			-- Wait for this coin's turn
			task.wait((i - 1) * DELAY_BETWEEN_COINS)

			-- Calculate angle for circular distribution
			local angulo = (i / NUM_COINS) * math.pi * 2
			angulo = angulo + (math.random() - 0.5) * 0.4

			-- Calculate direction
			local dirX = math.cos(angulo)
			local dirZ = math.sin(angulo)

			-- First Bezier: from collectPart outwards and up
			local radius1 = 1.5
			local radius2 = 3
			local height = 4

			local p0 = centro
			local p1 = centro + Vector3.new(dirX * radius1, height * 0.7, dirZ * radius1)
			local p2 = centro + Vector3.new(dirX * radius2, height, dirZ * radius2)

			-- Clone the money
			local moneda = moneyTemplate:Clone()
			moneda.CFrame = CFrame.new(p0)
			moneda.Anchored = true
			moneda.CanCollide = false
			moneda.Parent = workspace

			-- Remove the Effect sound from the cloned money (user requested this)
			local effectSound = moneda:FindFirstChild("Effect")
			if effectSound then
				effectSound:Destroy()
			end

			-- First Bezier curve (outward)
			local curvaBezier1 = Bezier.new(p0, p1, p2)
			local tweenInfo1 = TweenInfo.new(
				FIRST_BEZIER_DURATION,
				Enum.EasingStyle.Sine,
				Enum.EasingDirection.Out,
				0,
				false,
				0
			)

			local tween1 = curvaBezier1:CreateCFrameTween(moneda, {"CFrame"}, tweenInfo1, false)

			-- Add rotation
			local rotationTask = task.spawn(function()
				local startTime = tick()
				while tick() - startTime < FIRST_BEZIER_DURATION and moneda.Parent do
					local dt = task.wait()
					moneda.CFrame = moneda.CFrame * CFrame.Angles(0, dt * 22, 0)
				end
			end)

			tween1:Play()
			tween1.Completed:Wait()

			-- Bounce up and play Reward sound
			local currentPos = moneda.Position
			local bounceUp = currentPos + Vector3.new(0, BOUNCE_HEIGHT, 0)

			local bounceTween = TweenService:Create(moneda, TweenInfo.new(
				BOUNCE_DURATION,
				Enum.EasingStyle.Back,
				Enum.EasingDirection.Out
			), {Position = bounceUp})

			-- Play Reward sound
			if rewardSound then
				local rewardClone = rewardSound:Clone()
				rewardClone.Parent = moneda
				rewardClone:Play()
			end

			bounceTween:Play()
			bounceTween.Completed:Wait()

			-- Second Bezier: to CollectZone
			local p3 = moneda.Position
			local midPoint = (p3 + collectZoneCollectPart.Position) / 2 + Vector3.new(0, 3, 0)
			local p4 = collectZoneCollectPart.Position

			local curvaBezier2 = Bezier.new(p3, midPoint, p4)
			local tweenInfo2 = TweenInfo.new(
				SECOND_BEZIER_DURATION,
				Enum.EasingStyle.Sine,
				Enum.EasingDirection.In,
				0,
				false,
				0
			)

			-- Play Transition sound
			if transitionSound then
				local transitionClone = transitionSound:Clone()
				transitionClone.Parent = moneda
				transitionClone:Play()
			end

			local tween2 = curvaBezier2:CreateCFrameTween(moneda, {"CFrame"}, tweenInfo2, false)

			-- Continue rotation
			task.cancel(rotationTask)
			rotationTask = task.spawn(function()
				local startTime = tick()
				while tick() - startTime < SECOND_BEZIER_DURATION and moneda.Parent do
					local dt = task.wait()
					moneda.CFrame = moneda.CFrame * CFrame.Angles(0, dt * 22, 0)
				end
			end)

			tween2:Play()
			tween2.Completed:Wait()

			-- Play Collected sound at CollectZone
			if collectedSound then
				local collectedClone = collectedSound:Clone()
				collectedClone.Parent = collectZoneCollectPart
				collectedClone:Play()
				Debris:AddItem(collectedClone, collectedClone.TimeLength + 0.5)
			end

			-- Destroy the money
			if moneda and moneda.Parent then
				moneda:Destroy()
			end
		end)
	end
end

function JuiceCollection.updateAllJuicesMoneyGeneration()
	local JuiceSystemPath = ReplicatedStorage:WaitForChild("Modules"):WaitForChild("Utils"):WaitForChild("JuiceSystem")
	local JuiceSystemUtils = require(JuiceSystemPath:WaitForChild("JuiceSystemUtils"))

	for _, player in ipairs(Players:GetPlayers()) do
		local placedJuices = player:FindFirstChild("PlacedJuices")
		if placedJuices then
			-- Collect all valid juices for this player
			local validJuices = {}

			for _, juiceFolder in ipairs(placedJuices:GetChildren()) do
				if juiceFolder:IsA("Folder") then
					local pricePerSecValue = juiceFolder:FindFirstChild("PricePerSec")
					local moneyGeneratedValue = juiceFolder:FindFirstChild("MoneyGenerated")
					local slotValue = juiceFolder:FindFirstChild("Slot")

					if pricePerSecValue and pricePerSecValue:IsA("IntValue") and
						moneyGeneratedValue and moneyGeneratedValue:IsA("IntValue") and
						slotValue and slotValue:IsA("IntValue") then

						table.insert(validJuices, {
							pricePerSec = pricePerSecValue,
							moneyGenerated = moneyGeneratedValue,
							slot = slotValue,
							folder = juiceFolder
						})
					end
				end
			end

			-- Check for global bonus activation (2% chance per player)
			local bonusActivated = #validJuices > 0 and math.random() < BONUS_CHANCE

			if bonusActivated then
				-- Select a random juice to receive the bonus
				local randomIndex = math.random(1, #validJuices)
				local luckyJuice = validJuices[randomIndex]

				-- Apply bonus multiplier to the lucky juice
				local bonusMoney = math.floor(luckyJuice.pricePerSec.Value * BONUS_MULTIPLIER)
				luckyJuice.moneyGenerated.Value = luckyJuice.moneyGenerated.Value + bonusMoney

				-- Play bonus effect on the lucky juice's Collect part
				local slotModel = JuiceSystemUtils.findSlotModel(player, luckyJuice.slot.Value)
				if slotModel then
					local collectPart = slotModel:FindFirstChild("Collect")
					if collectPart and collectPart:IsA("BasePart") then
						JuiceCollection.playBonusEffect(collectPart, player)
					end
				end

				-- Apply normal generation to all other juices
				for i, juiceData in ipairs(validJuices) do
					if i ~= randomIndex then
						juiceData.moneyGenerated.Value = juiceData.moneyGenerated.Value + juiceData.pricePerSec.Value
					end
				end
			else
				-- No bonus: apply normal generation to all juices
				for _, juiceData in ipairs(validJuices) do
					juiceData.moneyGenerated.Value = juiceData.moneyGenerated.Value + juiceData.pricePerSec.Value
				end
			end
		end
	end
end

function JuiceCollection.startMoneyGenerationSystem()
	local lastUpdateTime = os.time()

	systemTrove:Connect(RunService.Heartbeat, function()
		local currentTime = os.time()

		if currentTime > lastUpdateTime then
			lastUpdateTime = currentTime
			JuiceCollection.updateAllJuicesMoneyGeneration()
		end
	end)
end

function JuiceCollection.calculateOfflineMoney(player)
	local success, lastDisconnectTime = pcall(function()
		return JuiceDataStore:GetAsync("Player_" .. player.UserId)
	end)

	if not success or not lastDisconnectTime then
		return
	end

	local currentTime = os.time()
	local timeOffline = currentTime - lastDisconnectTime

	if timeOffline <= 0 then return end

	local MAX_OFFLINE_TIME = 10800
	if timeOffline > MAX_OFFLINE_TIME then
		timeOffline = MAX_OFFLINE_TIME
	end

	local placedJuices = player:FindFirstChild("PlacedJuices")
	if not placedJuices then return end

	for _, juiceFolder in ipairs(placedJuices:GetChildren()) do
		if juiceFolder:IsA("Folder") then
			local pricePerSecValue = juiceFolder:FindFirstChild("PricePerSec")
			local moneyGeneratedValue = juiceFolder:FindFirstChild("MoneyGenerated")

			if pricePerSecValue and pricePerSecValue:IsA("IntValue") and
				moneyGeneratedValue and moneyGeneratedValue:IsA("IntValue") then

				local offlineMoney = pricePerSecValue.Value * timeOffline
				moneyGeneratedValue.Value = moneyGeneratedValue.Value + offlineMoney
			end
		end
	end
end

function JuiceCollection.saveDisconnectTime(player)
	local success, err = pcall(function()
		JuiceDataStore:SetAsync("Player_" .. player.UserId, os.time())
	end)
end

return JuiceCollection
