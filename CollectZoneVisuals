local ReplicatedStorage = game:GetService("ReplicatedStorage")
local TweenService = game:GetService("TweenService")

local CollectZoneVisuals = {}

-- Import JuiceSystemUtils to find the cloned model
local JuiceSystemPath = ReplicatedStorage:WaitForChild("Modules"):WaitForChild("Utils"):WaitForChild("JuiceSystem")
local JuiceSystemUtils = require(JuiceSystemPath:WaitForChild("JuiceSystemUtils"))

-- Constants
local MONEY_PER_CASH = 1500
local ROW_HEIGHT = 1 -- Each complete row occupies 1 stud in height

-- Animation settings
local CASH_APPEAR_TIME = 0.3
local FILLER_SCALE_TIME = 0.4
local ANIMATION_EASING_STYLE = Enum.EasingStyle.Back
local ANIMATION_EASING_DIRECTION = Enum.EasingDirection.Out

-- Cache for CollectZone data per player
local collectZoneCache = {}

local function getCollectZoneData(player)
	local userId = player.UserId
	if not collectZoneCache[userId] then
		collectZoneCache[userId] = {
			cashParts = {},
			fillerPart = nil,
			lastMoneyAmount = 0,
			lastCompleteLayers = 0,
			lastCashPartsCount = 0
		}
	end
	return collectZoneCache[userId]
end

function CollectZoneVisuals.clearPlayerCache(userId)
	if collectZoneCache[userId] then
		local data = collectZoneCache[userId]

		-- Destroy all cash parts
		for _, part in ipairs(data.cashParts) do
			if part and part.Parent then
				part:Destroy()
			end
		end

		-- Destroy filler part
		if data.fillerPart and data.fillerPart.Parent then
			data.fillerPart:Destroy()
		end

		collectZoneCache[userId] = nil
	end
end

local function getCashAndFillerTemplates()
	local assets = ReplicatedStorage:FindFirstChild("Assets")
	if not assets then
		warn("[CollectZoneVisuals] Assets folder not found")
		return nil, nil
	end

	local models = assets:FindFirstChild("Models")
	if not models then
		warn("[CollectZoneVisuals] Models folder not found")
		return nil, nil
	end

	local plot = models:FindFirstChild("Plot")
	if not plot then
		warn("[CollectZoneVisuals] Plot folder not found")
		return nil, nil
	end

	local collectZoneFolder = plot:FindFirstChild("CollectZone")
	if not collectZoneFolder then
		warn("[CollectZoneVisuals] CollectZone folder not found in Plot")
		return nil, nil
	end

	local cash = collectZoneFolder:FindFirstChild("Cash")
	local filler = collectZoneFolder:FindFirstChild("Filler")

	if not cash then
		warn("[CollectZoneVisuals] Cash template not found in CollectZone")
	else
		print("[CollectZoneVisuals] Cash template found:", cash:GetFullName())
	end

	if not filler then
		warn("[CollectZoneVisuals] Filler template not found in CollectZone")
	else
		print("[CollectZoneVisuals] Filler template found:", filler:GetFullName())
	end

	return cash, filler
end

local function getContentPart(collectZone)
	if not collectZone then
		warn("[CollectZoneVisuals] CollectZone is nil in getContentPart")
		return nil
	end

	-- Try to find Content part inside CollectZone
	for _, child in ipairs(collectZone:GetDescendants()) do
		if child.Name == "Content" and child:IsA("BasePart") then
			print("[CollectZoneVisuals] Content part found:", child:GetFullName(), "Size:", child.Size)
			return child
		end
	end

	warn("[CollectZoneVisuals] Content part not found in CollectZone:", collectZone:GetFullName())
	return nil
end

local function animateCashAppear(cashPart, targetCFrame)
	-- Start with the part at scale 0 (invisible)
	local originalSize = cashPart.Size
	cashPart.Size = Vector3.new(0, 0, 0)
	cashPart.CFrame = targetCFrame

	-- Create tween to scale up with bouncy effect
	local tweenInfo = TweenInfo.new(
		CASH_APPEAR_TIME,
		ANIMATION_EASING_STYLE,
		ANIMATION_EASING_DIRECTION,
		0,  -- Repeat count
		false,  -- Reverse
		0  -- Delay
	)

	local goal = {Size = originalSize}
	local tween = TweenService:Create(cashPart, tweenInfo, goal)
	tween:Play()

	return tween
end

local function calculateCashPositions(contentPart, cashSize, numCashParts)
	local positions = {}
	local orientations = {}

	if not contentPart then return positions, orientations, 0 end

	-- Get Content dimensions and rotation
	local contentSize = contentPart.Size
	local contentCFrame = contentPart.CFrame

	-- Calculate how many cash parts fit in one row (horizontally along X axis)
	local cashWidth = cashSize.X
	local cashDepth = cashSize.Z
	local cashHeight = cashSize.Y

	local partsPerRow = math.max(1, math.floor(contentSize.X / cashWidth))
	local partsPerDepth = math.max(1, math.floor(contentSize.Z / cashDepth))
	local partsPerLayer = partsPerRow * partsPerDepth

	-- Calculate starting position (bottom-left-front corner of Content)
	-- We start from the bottom because we'll build upwards
	local startOffset = Vector3.new(
		-contentSize.X / 2 + cashWidth / 2,  -- Start at left edge
		-contentSize.Y / 2 + cashHeight / 2,  -- Start at bottom
		-contentSize.Z / 2 + cashDepth / 2   -- Start at front
	)

	for i = 1, numCashParts do
		local index = i - 1

		-- Calculate which layer (vertical level), row (depth), and column (width)
		local layer = math.floor(index / partsPerLayer)
		local indexInLayer = index % partsPerLayer
		local row = math.floor(indexInLayer / partsPerRow)  -- Goes back in Z
		local col = indexInLayer % partsPerRow  -- Goes right in X

		-- Calculate position offset from starting position
		local offset = Vector3.new(
			col * cashWidth,      -- Move right
			layer * cashHeight,   -- Move up
			row * cashDepth       -- Move back
		)

		-- Calculate world position relative to Content part
		local localPos = startOffset + offset
		local worldPos = contentCFrame:PointToWorldSpace(localPos)
		local worldRot = contentCFrame.Rotation

		table.insert(positions, worldPos)
		table.insert(orientations, worldRot)
	end

	return positions, orientations, partsPerLayer
end

local function updateFillerPart(contentPart, fillerTemplate, numCompleteLayers, cashHeight, existingFiller)
	if numCompleteLayers <= 0 then
		-- No complete layers, remove filler if exists
		if existingFiller and existingFiller.Parent then
			existingFiller:Destroy()
		end
		return nil
	end

	local fillerPart = existingFiller
	local isNewFiller = false

	if not fillerPart or not fillerPart.Parent then
		fillerPart = fillerTemplate:Clone()
		isNewFiller = true
	end

	-- Calculate filler size and position
	local contentSize = contentPart.Size
	local contentCFrame = contentPart.CFrame

	-- Filler height is based on number of complete layers
	local fillerHeight = numCompleteLayers * cashHeight
	local targetSize = Vector3.new(contentSize.X, fillerHeight, contentSize.Z)

	-- Position filler at the bottom of content, centered
	-- The offset is from the center of content to the center of filler
	local fillerOffset = Vector3.new(
		0,  -- Centered horizontally
		-contentSize.Y / 2 + fillerHeight / 2,  -- Bottom-aligned, then offset up by half filler height
		0   -- Centered depth-wise
	)

	local fillerPos = contentCFrame:PointToWorldSpace(fillerOffset)
	local targetCFrame = CFrame.new(fillerPos) * contentCFrame.Rotation

	fillerPart.Anchored = true
	fillerPart.CanCollide = false

	if isNewFiller then
		-- New filler: start from scale 0 and animate to target size
		fillerPart.Size = Vector3.new(0, 0, 0)
		fillerPart.CFrame = targetCFrame
		fillerPart.Parent = contentPart

		local tweenInfo = TweenInfo.new(
			FILLER_SCALE_TIME,
			ANIMATION_EASING_STYLE,
			ANIMATION_EASING_DIRECTION,
			0,
			false,
			0
		)

		local goal = {Size = targetSize}
		local tween = TweenService:Create(fillerPart, tweenInfo, goal)
		tween:Play()
	else
		-- Existing filler: animate from current size to new size
		local currentSize = fillerPart.Size

		-- Only animate if size actually changed
		if currentSize ~= targetSize then
			local tweenInfo = TweenInfo.new(
				FILLER_SCALE_TIME,
				ANIMATION_EASING_STYLE,
				ANIMATION_EASING_DIRECTION,
				0,
				false,
				0
			)

			local goal = {
				Size = targetSize,
				CFrame = targetCFrame
			}
			local tween = TweenService:Create(fillerPart, tweenInfo, goal)
			tween:Play()
		else
			-- Size didn't change, just update CFrame if needed
			fillerPart.CFrame = targetCFrame
		end
	end

	return fillerPart
end

function CollectZoneVisuals.updateCollectZoneVisuals(player, totalMoneyGenerated)
	local userId = player.UserId
	local data = getCollectZoneData(player)

	print("[CollectZoneVisuals] updateCollectZoneVisuals called for player:", player.Name, "Money:", totalMoneyGenerated)

	-- Only update if money changed
	if data.lastMoneyAmount == totalMoneyGenerated then
		print("[CollectZoneVisuals] Money hasn't changed, skipping update")
		return
	end

	data.lastMoneyAmount = totalMoneyGenerated

	-- Calculate how many cash parts we need
	local numCashParts = math.floor(totalMoneyGenerated / MONEY_PER_CASH)
	print("[CollectZoneVisuals] Number of cash parts needed:", numCashParts)

	-- Get templates
	local cashTemplate, fillerTemplate = getCashAndFillerTemplates()
	if not cashTemplate then
		warn("[CollectZoneVisuals] Cash template not found, aborting")
		return
	end

	-- Find CollectZone using JuiceSystemUtils
	local collectZone = JuiceSystemUtils.findCollectZone(player)
	if not collectZone then
		warn("[CollectZoneVisuals] CollectZone not found for player:", player.Name)
		return
	end

	print("[CollectZoneVisuals] CollectZone found:", collectZone:GetFullName())

	local contentPart = getContentPart(collectZone)
	if not contentPart then
		warn("[CollectZoneVisuals] Content part not found in CollectZone, aborting")
		return
	end

	-- Get cash size from template
	local cashSize = cashTemplate.Size

	-- Calculate how many parts fit per layer
	local contentSize = contentPart.Size
	local partsPerRow = math.max(1, math.floor(contentSize.X / cashSize.X))
	local partsPerDepth = math.max(1, math.floor(contentSize.Z / cashSize.Z))
	local partsPerLayer = partsPerRow * partsPerDepth

	-- Calculate maximum layers that can fit in Content height
	local maxLayersThatFit = math.max(1, math.floor(contentSize.Y / cashSize.Y))

	print("[CollectZoneVisuals] Parts per layer:", partsPerLayer, "Max layers that fit:", maxLayersThatFit)

	-- Calculate how many complete layers we have (limited by Content height)
	local totalLayersNeeded = math.ceil(numCashParts / partsPerLayer)
	local actualTotalLayers = math.min(totalLayersNeeded, maxLayersThatFit)

	-- If we exceed the max layers, cap it and show only what fits
	local actualNumCashParts = math.min(numCashParts, actualTotalLayers * partsPerLayer)
	local numCompleteLayers = math.floor(actualNumCashParts / partsPerLayer)

	-- The top layer shows individual cash parts
	local cashPartsInTopLayer = actualNumCashParts % partsPerLayer
	if cashPartsInTopLayer == 0 and actualNumCashParts > 0 then
		-- If top layer is complete, show it as cash parts
		cashPartsInTopLayer = partsPerLayer
		numCompleteLayers = numCompleteLayers - 1
	end

	print("[CollectZoneVisuals] Actual layers:", actualTotalLayers, "Complete layers:", numCompleteLayers, "Cash parts in top layer:", cashPartsInTopLayer)

	-- Check if we need to recreate all parts (layer changed or money decreased significantly)
	local needsFullRecreate = false
	if numCompleteLayers ~= data.lastCompleteLayers then
		-- Layer changed, need to reposition all parts
		needsFullRecreate = true
		print("[CollectZoneVisuals] Layer changed from", data.lastCompleteLayers, "to", numCompleteLayers, "- full recreate needed")
	elseif cashPartsInTopLayer < data.lastCashPartsCount then
		-- Money decreased, need to remove excess parts
		needsFullRecreate = true
		print("[CollectZoneVisuals] Cash parts decreased from", data.lastCashPartsCount, "to", cashPartsInTopLayer, "- full recreate needed")
	end

	-- Update tracking
	data.lastCompleteLayers = numCompleteLayers
	data.lastCashPartsCount = cashPartsInTopLayer

	if needsFullRecreate then
		-- Clear existing cash parts
		print("[CollectZoneVisuals] Clearing all existing cash parts")
		for _, part in ipairs(data.cashParts) do
			if part and part.Parent then
				part:Destroy()
			end
		end
		data.cashParts = {}
	end

	-- Create or add cash parts for the top layer
	if cashPartsInTopLayer > 0 then
		local existingCount = #data.cashParts
		local partsToCreate = cashPartsInTopLayer - existingCount

		if partsToCreate > 0 then
			print("[CollectZoneVisuals] Adding", partsToCreate, "new cash parts (already have", existingCount, ")")
			-- Calculate positions starting from bottom, then offset to top layer
			local positions, orientations = calculateCashPositions(contentPart, cashSize, cashPartsInTopLayer)

			-- Only create the new parts we need
			for i = existingCount + 1, cashPartsInTopLayer do
				if positions[i] then
					local cashPart = cashTemplate:Clone()

					-- Apply vertical offset to move to the top layer
					local layerOffset = Vector3.new(0, numCompleteLayers * cashSize.Y, 0)
					local finalPos = positions[i] + layerOffset
					local targetCFrame = CFrame.new(finalPos) * orientations[i]

					cashPart.Anchored = true
					cashPart.CanCollide = false
					cashPart.Parent = contentPart

					-- Animate the cash part appearing with bouncy effect
					animateCashAppear(cashPart, targetCFrame)

					table.insert(data.cashParts, cashPart)
				end
			end
			print("[CollectZoneVisuals] Total cash parts now:", #data.cashParts)
		else
			print("[CollectZoneVisuals] No new cash parts needed (already have", existingCount, ")")
		end
	else
		print("[CollectZoneVisuals] No cash parts to show in top layer")
	end

	-- Update or create filler for complete layers
	if fillerTemplate then
		print("[CollectZoneVisuals] Updating filler for", numCompleteLayers, "complete layers")
		data.fillerPart = updateFillerPart(contentPart, fillerTemplate, numCompleteLayers, cashSize.Y, data.fillerPart)
		if data.fillerPart then
			print("[CollectZoneVisuals] Filler part created/updated, Size:", data.fillerPart.Size)
		end
	end

	print("[CollectZoneVisuals] Update complete!")
end

function CollectZoneVisuals.initializeCollectZoneVisuals(player)
	print("[CollectZoneVisuals] initializeCollectZoneVisuals called for player:", player.Name)

	-- Initialize with current money
	local placedJuices = player:FindFirstChild("PlacedJuices")
	if not placedJuices then
		warn("[CollectZoneVisuals] PlacedJuices folder not found")
		return
	end

	local totalMoney = 0
	for _, juiceFolder in ipairs(placedJuices:GetChildren()) do
		if juiceFolder:IsA("Folder") then
			local moneyGenerated = juiceFolder:FindFirstChild("MoneyGenerated")
			if moneyGenerated and moneyGenerated:IsA("IntValue") then
				totalMoney = totalMoney + moneyGenerated.Value
			end
		end
	end

	print("[CollectZoneVisuals] Initializing with total money:", totalMoney)
	CollectZoneVisuals.updateCollectZoneVisuals(player, totalMoney)
end

return CollectZoneVisuals
