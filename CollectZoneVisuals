local ReplicatedStorage = game:GetService("ReplicatedStorage")

local CollectZoneVisuals = {}

-- Import JuiceSystemUtils to find the cloned model
local JuiceSystemPath = ReplicatedStorage:WaitForChild("Modules"):WaitForChild("Utils"):WaitForChild("JuiceSystem")
local JuiceSystemUtils = require(JuiceSystemPath:WaitForChild("JuiceSystemUtils"))

-- Constants
local MONEY_PER_CASH = 1500
local ROW_HEIGHT = 1 -- Each complete row occupies 1 stud in height

-- Cache for CollectZone data per player
local collectZoneCache = {}

local function getCollectZoneData(player)
	local userId = player.UserId
	if not collectZoneCache[userId] then
		collectZoneCache[userId] = {
			cashParts = {},
			fillerPart = nil,
			lastMoneyAmount = 0
		}
	end
	return collectZoneCache[userId]
end

function CollectZoneVisuals.clearPlayerCache(userId)
	if collectZoneCache[userId] then
		local data = collectZoneCache[userId]

		-- Destroy all cash parts
		for _, part in ipairs(data.cashParts) do
			if part and part.Parent then
				part:Destroy()
			end
		end

		-- Destroy filler part
		if data.fillerPart and data.fillerPart.Parent then
			data.fillerPart:Destroy()
		end

		collectZoneCache[userId] = nil
	end
end

local function getCashAndFillerTemplates()
	local assets = ReplicatedStorage:FindFirstChild("Assets")
	if not assets then
		warn("[CollectZoneVisuals] Assets folder not found")
		return nil, nil
	end

	local models = assets:FindFirstChild("Models")
	if not models then
		warn("[CollectZoneVisuals] Models folder not found")
		return nil, nil
	end

	local plot = models:FindFirstChild("Plot")
	if not plot then
		warn("[CollectZoneVisuals] Plot folder not found")
		return nil, nil
	end

	local collectZoneFolder = plot:FindFirstChild("CollectZone")
	if not collectZoneFolder then
		warn("[CollectZoneVisuals] CollectZone folder not found in Plot")
		return nil, nil
	end

	local cash = collectZoneFolder:FindFirstChild("Cash")
	local filler = collectZoneFolder:FindFirstChild("Filler")

	if not cash then
		warn("[CollectZoneVisuals] Cash template not found in CollectZone")
	else
		print("[CollectZoneVisuals] Cash template found:", cash:GetFullName())
	end

	if not filler then
		warn("[CollectZoneVisuals] Filler template not found in CollectZone")
	else
		print("[CollectZoneVisuals] Filler template found:", filler:GetFullName())
	end

	return cash, filler
end

local function getContentPart(collectZone)
	if not collectZone then
		warn("[CollectZoneVisuals] CollectZone is nil in getContentPart")
		return nil
	end

	-- Try to find Content part inside CollectZone
	for _, child in ipairs(collectZone:GetDescendants()) do
		if child.Name == "Content" and child:IsA("BasePart") then
			print("[CollectZoneVisuals] Content part found:", child:GetFullName(), "Size:", child.Size)
			return child
		end
	end

	warn("[CollectZoneVisuals] Content part not found in CollectZone:", collectZone:GetFullName())
	return nil
end

local function calculateCashPositions(contentPart, cashSize, numCashParts)
	local positions = {}
	local orientations = {}

	if not contentPart then return positions, orientations, 0 end

	-- Get Content dimensions and rotation
	local contentSize = contentPart.Size
	local contentCFrame = contentPart.CFrame

	-- Calculate how many cash parts fit in one row (horizontally along X axis)
	local cashWidth = cashSize.X
	local cashDepth = cashSize.Z
	local cashHeight = cashSize.Y

	local partsPerRow = math.max(1, math.floor(contentSize.X / cashWidth))
	local partsPerDepth = math.max(1, math.floor(contentSize.Z / cashDepth))
	local partsPerLayer = partsPerRow * partsPerDepth

	-- Calculate starting position (bottom-left-front corner of Content)
	-- We start from the bottom because we'll build upwards
	local startOffset = Vector3.new(
		-contentSize.X / 2 + cashWidth / 2,  -- Start at left edge
		-contentSize.Y / 2 + cashHeight / 2,  -- Start at bottom
		-contentSize.Z / 2 + cashDepth / 2   -- Start at front
	)

	for i = 1, numCashParts do
		local index = i - 1

		-- Calculate which layer (vertical level), row (depth), and column (width)
		local layer = math.floor(index / partsPerLayer)
		local indexInLayer = index % partsPerLayer
		local row = math.floor(indexInLayer / partsPerRow)  -- Goes back in Z
		local col = indexInLayer % partsPerRow  -- Goes right in X

		-- Calculate position offset from starting position
		local offset = Vector3.new(
			col * cashWidth,      -- Move right
			layer * cashHeight,   -- Move up
			row * cashDepth       -- Move back
		)

		-- Calculate world position relative to Content part
		local localPos = startOffset + offset
		local worldPos = contentCFrame:PointToWorldSpace(localPos)
		local worldRot = contentCFrame.Rotation

		table.insert(positions, worldPos)
		table.insert(orientations, worldRot)
	end

	return positions, orientations, partsPerLayer
end

local function updateFillerPart(contentPart, fillerTemplate, numCompleteLayers, cashHeight, existingFiller)
	if numCompleteLayers <= 0 then
		-- No complete layers, remove filler if exists
		if existingFiller and existingFiller.Parent then
			existingFiller:Destroy()
		end
		return nil
	end

	local fillerPart = existingFiller

	if not fillerPart or not fillerPart.Parent then
		fillerPart = fillerTemplate:Clone()
	end

	-- Calculate filler size and position
	local contentSize = contentPart.Size
	local contentCFrame = contentPart.CFrame

	-- Filler height is based on number of complete layers
	local fillerHeight = numCompleteLayers * cashHeight
	local fillerSize = Vector3.new(contentSize.X, fillerHeight, contentSize.Z)

	-- Position filler at the bottom of content, centered
	-- The offset is from the center of content to the center of filler
	local fillerOffset = Vector3.new(
		0,  -- Centered horizontally
		-contentSize.Y / 2 + fillerHeight / 2,  -- Bottom-aligned, then offset up by half filler height
		0   -- Centered depth-wise
	)

	local fillerPos = contentCFrame:PointToWorldSpace(fillerOffset)

	fillerPart.Size = fillerSize
	fillerPart.CFrame = CFrame.new(fillerPos) * contentCFrame.Rotation
	fillerPart.Anchored = true
	fillerPart.CanCollide = false

	if not fillerPart.Parent then
		fillerPart.Parent = contentPart
	end

	return fillerPart
end

function CollectZoneVisuals.updateCollectZoneVisuals(player, totalMoneyGenerated)
	local userId = player.UserId
	local data = getCollectZoneData(player)

	print("[CollectZoneVisuals] updateCollectZoneVisuals called for player:", player.Name, "Money:", totalMoneyGenerated)

	-- Only update if money changed
	if data.lastMoneyAmount == totalMoneyGenerated then
		print("[CollectZoneVisuals] Money hasn't changed, skipping update")
		return
	end

	data.lastMoneyAmount = totalMoneyGenerated

	-- Calculate how many cash parts we need
	local numCashParts = math.floor(totalMoneyGenerated / MONEY_PER_CASH)
	print("[CollectZoneVisuals] Number of cash parts needed:", numCashParts)

	-- Get templates
	local cashTemplate, fillerTemplate = getCashAndFillerTemplates()
	if not cashTemplate then
		warn("[CollectZoneVisuals] Cash template not found, aborting")
		return
	end

	-- Find CollectZone using JuiceSystemUtils
	local collectZone = JuiceSystemUtils.findCollectZone(player)
	if not collectZone then
		warn("[CollectZoneVisuals] CollectZone not found for player:", player.Name)
		return
	end

	print("[CollectZoneVisuals] CollectZone found:", collectZone:GetFullName())

	local contentPart = getContentPart(collectZone)
	if not contentPart then
		warn("[CollectZoneVisuals] Content part not found in CollectZone, aborting")
		return
	end

	-- Get cash size from template
	local cashSize = cashTemplate.Size

	-- Calculate how many parts fit per layer
	local contentSize = contentPart.Size
	local partsPerRow = math.max(1, math.floor(contentSize.X / cashSize.X))
	local partsPerDepth = math.max(1, math.floor(contentSize.Z / cashSize.Z))
	local partsPerLayer = partsPerRow * partsPerDepth

	-- Calculate maximum layers that can fit in Content height
	local maxLayersThatFit = math.max(1, math.floor(contentSize.Y / cashSize.Y))

	print("[CollectZoneVisuals] Parts per layer:", partsPerLayer, "Max layers that fit:", maxLayersThatFit)

	-- Calculate how many complete layers we have (limited by Content height)
	local totalLayersNeeded = math.ceil(numCashParts / partsPerLayer)
	local actualTotalLayers = math.min(totalLayersNeeded, maxLayersThatFit)

	-- If we exceed the max layers, cap it and show only what fits
	local actualNumCashParts = math.min(numCashParts, actualTotalLayers * partsPerLayer)
	local numCompleteLayers = math.floor(actualNumCashParts / partsPerLayer)

	-- The top layer shows individual cash parts
	local cashPartsInTopLayer = actualNumCashParts % partsPerLayer
	if cashPartsInTopLayer == 0 and actualNumCashParts > 0 then
		-- If top layer is complete, show it as cash parts
		cashPartsInTopLayer = partsPerLayer
		numCompleteLayers = numCompleteLayers - 1
	end

	print("[CollectZoneVisuals] Actual layers:", actualTotalLayers, "Complete layers:", numCompleteLayers, "Cash parts in top layer:", cashPartsInTopLayer)

	-- Clear existing cash parts
	for _, part in ipairs(data.cashParts) do
		if part and part.Parent then
			part:Destroy()
		end
	end
	data.cashParts = {}

	-- Create cash parts for the top layer only
	if cashPartsInTopLayer > 0 then
		print("[CollectZoneVisuals] Creating", cashPartsInTopLayer, "cash parts for top layer")
		-- Calculate positions starting from bottom, then offset to top layer
		local positions, orientations = calculateCashPositions(contentPart, cashSize, cashPartsInTopLayer)
		print("[CollectZoneVisuals] Calculated", #positions, "positions")

		for i = 1, cashPartsInTopLayer do
			if positions[i] then
				local cashPart = cashTemplate:Clone()

				-- Apply vertical offset to move to the top layer
				local layerOffset = Vector3.new(0, numCompleteLayers * cashSize.Y, 0)
				local finalPos = positions[i] + layerOffset

				cashPart.CFrame = CFrame.new(finalPos) * orientations[i]
				cashPart.Anchored = true
				cashPart.CanCollide = false
				cashPart.Parent = contentPart

				table.insert(data.cashParts, cashPart)
				print("[CollectZoneVisuals] Created cash part", i, "at position:", finalPos)
			end
		end
		print("[CollectZoneVisuals] Total cash parts created:", #data.cashParts)
	else
		print("[CollectZoneVisuals] No cash parts to show in top layer")
	end

	-- Update or create filler for complete layers
	if fillerTemplate then
		print("[CollectZoneVisuals] Updating filler for", numCompleteLayers, "complete layers")
		data.fillerPart = updateFillerPart(contentPart, fillerTemplate, numCompleteLayers, cashSize.Y, data.fillerPart)
		if data.fillerPart then
			print("[CollectZoneVisuals] Filler part created/updated, Size:", data.fillerPart.Size)
		end
	end

	print("[CollectZoneVisuals] Update complete!")
end

function CollectZoneVisuals.initializeCollectZoneVisuals(player)
	print("[CollectZoneVisuals] initializeCollectZoneVisuals called for player:", player.Name)

	-- Initialize with current money
	local placedJuices = player:FindFirstChild("PlacedJuices")
	if not placedJuices then
		warn("[CollectZoneVisuals] PlacedJuices folder not found")
		return
	end

	local totalMoney = 0
	for _, juiceFolder in ipairs(placedJuices:GetChildren()) do
		if juiceFolder:IsA("Folder") then
			local moneyGenerated = juiceFolder:FindFirstChild("MoneyGenerated")
			if moneyGenerated and moneyGenerated:IsA("IntValue") then
				totalMoney = totalMoney + moneyGenerated.Value
			end
		end
	end

	print("[CollectZoneVisuals] Initializing with total money:", totalMoney)
	CollectZoneVisuals.updateCollectZoneVisuals(player, totalMoney)
end

return CollectZoneVisuals
